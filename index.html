<!DOCTYPE html>
<html lang="en-GB">
<head>
<meta charset="UTF-8">
<title>WMSA NOTAM VISUALIZER</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.15.1/css/ol.css" type="text/css">
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f0f0f0; }
#map { width: 100%; height: 100vh; position: relative; }
.loading-overlay {
position: fixed; top: 0; left: 0; width: 100%; height: 100%;
background: rgba(255,255,255,0.95); z-index: 9999;
display: flex; flex-direction: column; justify-content: center;
align-items: center; gap: 20px;
}
.loading-spinner {
border: 4px solid #f3f3f3;
border-top: 4px solid #004494;
border-radius: 50%;
width: 50px; height: 50px;
animation: spin 1s linear infinite;
}
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
.loading-text { font-size: 16px; color: #004494; font-weight: bold; }
.error-message {
position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
background: #c82333; color: white; padding: 15px 30px;
border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
z-index: 10000; font-weight: bold; display: none;
}
/* PANELS */
.panel-right, .panel-left {
position: absolute; top: 10px; z-index: 1000;
background: white; padding: 12px; box-shadow: 0 0 8px rgba(0,0,0,0.2);
border-radius: 5px; transition: all 0.3s ease;
font-size: 13px;
}
.panel-right { right: 10px; width: 380px; }
.panel-left { left: 10px; width: 320px; }
.panel-right.minimized, .panel-left.minimized {
height: 36px; overflow: hidden; padding: 5px 12px;
}
.panel-right.minimized .content, .panel-left.minimized .content {
display: none;
}
.panel-header {
display: flex; justify-content: space-between; align-items: center;
margin: -12px -12px 12px -12px; padding: 6px 12px;
background: #004494; /* darker blue */
color: white; border-radius: 5px 5px 0 0;
cursor: move;
}
.panel-header h3 {
margin: 0; font-size: 14px; font-weight: bold;
}
input, textarea, button, select {
width: 100%; margin: 4px 0; padding: 6px; box-sizing: border-box;
font-size: 13px;
}
textarea { height: 50px; }
button {
cursor: pointer; background: #004494; color: white; border: none;
font-weight: bold; font-size: 13px; padding: 6px;
}
button:hover { background: #003377; }
button.danger { background: #c82333; }
button.danger:hover { background: #bd2130; }
button.small {
padding: 3px 6px; font-size: 12px; width: auto;
}
button.success {
background: #28a745;
}
button.success:hover {
background: #218838;
}
/* HIGH CONTRAST TOGGLE BUTTON */
button.panel-toggle {
padding: 4px 8px;
font-size: 18px;
font-weight: bold;
background: white;
color: black;
border: 2px solid black;
border-radius: 4px;
cursor: pointer;
width: 32px;
height: 32px;
display: flex;
align-items: center;
justify-content: center;
}
button.panel-toggle:hover {
background: #f0f0f0;
}
/* FLOATING SEARCH BAR */
#floatingSearch {
position: fixed;
top: 10px;
left: 50%;
transform: translateX(-50%);
z-index: 2000;
width: 550px;
background: white;
padding: 8px 12px;
border-radius: 20px;
box-shadow: 0 2px 10px rgba(0,0,0,0.3);
display: flex;
flex-direction: column;
gap: 8px;
}
#floatingSearch input {
width: 100%;
border: 2px solid #004494;
border-radius: 15px;
padding: 6px 12px;
font-size: 13px;
font-weight: bold;
}
#floatingSearch input:focus {
outline: none;
border-color: #003377;
box-shadow: 0 0 5px rgba(0,59,130,0.5);
}
/* FILTER BUTTONS */
.filter-buttons {
display: flex;
gap: 6px;
flex-wrap: wrap;
}
.filter-btn {
flex: 1;
min-width: 120px;
padding: 6px;
border-radius: 4px;
border: none;
font-weight: bold;
font-size: 12px;
cursor: pointer;
}
.filter-btn.all { background: #004494; color: white; }
.filter-btn.active { background: #c82333; color: white; }
.filter-btn.pending { background: #0066cc; color: white; }
.filter-btn.expired { background: #666666; color: white; }
.filter-btn:hover { opacity: 0.9; }
/* SCROLLABLE CONTENT */
.content {
max-height: calc(100vh - 100px);
overflow-y: auto;
padding-right: 4px;
}
.content::-webkit-scrollbar { width: 8px; }
.content::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 4px; }
.content::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
.content::-webkit-scrollbar-thumb:hover { background: #555; }
/* ZONE LIST - COMPACT */
#zoneListPanel { text-transform: uppercase; }
.zone-item {
padding: 6px; margin: 4px 0; background: #f9f9f9; border-radius: 3px;
display: flex; flex-direction: column; font-size: 12px;
border-left: 3px solid transparent;
}
.zone-item.highlight {
border-left: 3px solid #004494;
background: #e9f7ff;
}
.zone-header {
display: flex; justify-content: space-between; align-items: center;
margin-bottom: 3px;
}
.color-box {
width: 12px; height: 12px; margin-right: 6px; display: inline-block;
}
.zone-main {
display: flex; align-items: flex-start; gap: 6px;
margin-bottom: 3px;
}
.zone-desc {
flex: 1; word-wrap: break-word;
}
.toggle-label-icon {
cursor: pointer; font-size: 16px; color: #555; padding: 2px;
border-radius: 3px;
}
.toggle-label-icon:hover { background: #eee; }
.edit-icon, .delete-icon {
background: none; border: none; font-size: 16px; padding: 0; margin: 0; font-weight: bold;
cursor: pointer;
}
.edit-icon { color: #204d74; }
.delete-icon { color: #c82333; }
.edit-icon:hover { color: #122b40; }
.delete-icon:hover { color: #bd2130; }
/* COORD INPUT */
.coord-inputs {
margin-top: 10px; padding: 8px; background: #f5f5f5; border-radius: 4px;
}
.points-preview {
max-height: 100px; overflow-y: auto; margin: 8px 0; padding: 6px;
background: #eef; border-radius: 3px; font-size: 11px;
}
.point-tag {
display: inline-block; background: #004494; color: white;
padding: 1px 4px; margin: 1px 0; border-radius: 2px; font-size: 10px;
}
.point-tag button {
color: white; background: none; border: none; padding: 0 2px;
cursor: pointer; font-weight: bold; font-size: 10px;
}
.status-pending { color: #0066cc; font-weight: bold; font-size: 11px; }
.status-active { color: #c82333; font-weight: bold; font-size: 11px; }
.status-expired { color: #666; font-weight: bold; font-size: 11px; }
.error { border: 2px solid #c82333 !important; }
/* EDIT MODAL */
#editModal {
display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
background: rgba(0,0,0,0.5); z-index: 9999;
}
#editModal > div {
background: white; width: 90%; max-width: 500px; margin: 50px auto; 
padding: 20px; border-radius: 8px;
}
#editModal h3 { margin-top: 0; }
#editModal button { width: auto; padding: 8px 16px; margin: 5px; }
/* CIRCLE INPUT SECTION */
.circle-input-section {
margin-top: 15px; padding: 12px; background: #f0f8ff; border-radius: 4px; 
border: 1px solid #004494;
}
.circle-input-section h4 {
margin: 0 0 10px 0; font-size: 13px; color: #004494; font-weight: bold;
}
.info-footer {
position: fixed; bottom: 10px; left: 10px; z-index: 1000;
background: rgba(0,68,148,0.9); color: white; padding: 8px 15px;
border-radius: 4px; font-size: 12px; font-weight: bold;
box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}
</style>
</head>
<body>
<!-- LOADING OVERLAY -->
<div class="loading-overlay" id="loadingOverlay">
<div class="loading-spinner"></div>
<div class="loading-text">Loading WMSA NOTAM Data...</div>
</div>

<!-- ERROR MESSAGE -->
<div class="error-message" id="errorMessage"></div>

<!-- FLOATING SEARCH BAR WITH FILTER BUTTONS -->
<div id="floatingSearch">
<input type="text" id="searchInput" placeholder="üîç Search by ID or Description" autocomplete="off">
<div class="filter-buttons">
<button class="filter-btn all" id="showAllBtn">Show All</button>
<button class="filter-btn active" id="showActiveBtn">Active NOTAM</button>
<button class="filter-btn pending" id="showPendingBtn">Pending NOTAM</button>
<button class="filter-btn expired" id="showExpiredBtn">Expired NOTAM</button>
</div>
</div>

<!-- EDIT MODAL -->
<div id="editModal">
<div>
<h3>Edit Zone</h3>
<input type="text" id="editId" placeholder="NOTAM ID" style="width:100%; margin:5px 0; padding:8px; text-transform:uppercase;">
<textarea id="editDesc" placeholder="Description" style="width:100%; height:60px; margin:5px 0; padding:8px;"></textarea>
<div style="display:flex; gap:5px;">
<input type="number" id="editMinAlt" placeholder="Min Alt (ft)" style="width:48%; padding:8px;">
<input type="number" id="editMaxAlt" placeholder="Max Alt (ft)" style="width:48%; padding:8px;">
</div>
<input type="datetime-local" id="editStartTime" style="width:100%; margin:5px 0; padding:8px;">
<input type="datetime-local" id="editEndTime" style="width:100%; margin:5px 0; padding:8px;">
<div style="margin-top:15px; display:flex; gap:10px;">
<button id="saveEditBtn" style="flex:1; background:#28a745; color:white; border:none; padding:10px; font-weight:bold;">üíæ Save Changes</button>
<button id="cancelEditBtn" style="flex:1; background:#c82333; color:white; border:none; padding:10px; font-weight:bold;">‚ùå Cancel</button>
</div>
</div>
</div>

<!-- RIGHT PANEL: Create Zones -->
<div class="panel-right minimized" id="controlPanel">
<div class="panel-header">
<h3>ü°∫ Create Zone</h3>
<button id="toggleRightPanelBtn" class="panel-toggle">‚ñ≤</button>
</div>
<div class="content">
<input type="text" id="zoneId" placeholder="NOTAM SERIES" required style="text-transform:uppercase;">
<textarea id="zoneDesc" placeholder="DESCRIPTION" required></textarea>
<div style="display:flex; gap:5px;">
<input type="number" id="minAlt" placeholder="Min Alt (ft)" min="0" style="width:48%;">
<input type="number" id="maxAlt" placeholder="Max Alt (ft)" min="0" style="width:48%;">
</div>
<label style="font-size:12px;">‚è∞ Start Time (UTC)</label>
<input type="datetime-local" id="startTime" placeholder="Start (UTC)">
<label style="font-size:12px;">‚è∞ End Time (UTC)</label>
<input type="datetime-local" id="endTime" placeholder="End (UTC)">
<button id="openCoordBtn">üìç Add by Coordinates</button>
<div id="coordSection" style="display:none;" class="coord-inputs">
<input type="text" id="singleCoordInput" placeholder="Coordinates (Lat, Lng) e.g., 3.137489, 101.526181" style="width:100%; padding:6px; margin-bottom:8px;">
<button id="addPointBtn" class="small" style="width:100%;">+ Add Point</button>
<div class="points-preview" id="pointsPreview"></div>
<div style="margin-top:8px; display:flex; gap:5px;">
<button id="createPolyBtn" class="small" style="background:#28a745; width:48%;">‚úÖ Create</button>
<button id="clearPointsBtn" class="small danger" style="width:48%;">üóëÔ∏è Clear</button>
</div>
</div>

<!-- CIRCLE ZONE SECTION - SINGLE INPUT -->
<div class="circle-input-section">
<h4>‚≠ï Create Circular Zone</h4>
<input type="number" id="circleRadiusNm" placeholder="Radius (Nm)" min="0.1" step="0.1" style="width:100%; padding:8px; margin-bottom:8px;">
<input type="text" id="circleCenterCoord" placeholder="Center (Lat, Lng) e.g., 3.137489, 101.526181" style="width:100%; padding:8px;">
<button id="createCircleBtn" style="background:#004494; width:100%; padding:8px; margin-top:8px;">‚≠ï Create Circle</button>
</div>

<hr style="margin:10px 0;">
<button id="exportBtn" class="success">üì§ Export User Zones</button>
<button id="importBtn">üì• Import User Zones</button>
<input type="file" id="importFile" accept=".json" style="display:none;">
<div style="margin-top:10px; padding:8px; background:#f9f9f9; border-radius:4px; font-size:11px;">
<strong>‚ÑπÔ∏è Info:</strong><br>
‚Ä¢ Data loaded from notams.json<br>
‚Ä¢ User zones saved locally<br>
‚Ä¢ Export to backup your data
</div>
</div>
</div>

<!-- LEFT PANEL: Zone List -->
<div class="panel-left minimized" id="zoneListPanel">
<div class="panel-header">
<h3>üìã Zones (0)</h3>
<button id="toggleLeftPanelBtn" class="panel-toggle">‚ñ≤</button>
</div>
<div class="content">
<div id="zoneListContainer">
<div style="padding:10px; color:#888; font-size:12px;">Loading NOTAM data...</div>
</div>
</div>
</div>

<div id="map"></div>

<!-- INFO FOOTER -->
<div class="info-footer">
WMSA NOTAM Visualizer | Data: notams.json | Last Updated: <span id="lastUpdated">-</span>
</div>

<script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.15.1/build/ol.js"></script>
<script>
// =============================
// CONFIGURATION
// =============================
const DATA_FILE = 'notams.json';
const USER_DATA_KEY = 'wmsaUserZones';

// =============================
// üó∫Ô∏è MAP ‚Äî ROTATED 240¬∞ CLOCKWISE
// =============================
const center = ol.proj.fromLonLat([101.53, 3.13]);
const rotationRad = (240 * Math.PI) / 180;
const map = new ol.Map({
target: 'map',
layers: [
new ol.layer.Tile({
source: new ol.source.OSM()
})
],
view: new ol.View({
center: center,
zoom: 12,
rotation: -rotationRad
})
});

// =============================
// UTILITY FUNCTIONS
// =============================
function decimalToDMS(decimal, isLat) {
const abs = Math.abs(decimal);
const deg = Math.floor(abs);
const minFull = (abs - deg) * 60;
const min = Math.floor(minFull);
const sec = Math.round((minFull - min) * 60);
const dir = isLat ? (decimal >= 0 ? 'N' : 'S') : (decimal >= 0 ? 'E' : 'W');
return `${String(deg).padStart(2,'0')}${String(min).padStart(2,'0')}${String(sec).padStart(2,'0')}${dir}`.substring(0,11);
}

function dmsToDecimal(dms) {
const m = dms.match(/(\d{2})(\d{2})(\d{2})([NSEW])/i);
if (!m) return null;
let dec = parseInt(m[1]) + parseInt(m[2])/60 + parseInt(m[3])/3600;
return (m[4].toUpperCase() === 'S' || m[4].toUpperCase() === 'W') ? -dec : dec;
}

function showError(message) {
const el = document.getElementById('errorMessage');
el.textContent = message;
el.style.display = 'block';
setTimeout(() => { el.style.display = 'none'; }, 5000);
}

function hideLoading() {
document.getElementById('loadingOverlay').style.display = 'none';
}

// =============================
// POPUP HANDLER
// =============================
let zones = [];
map.on('click', function(evt) {
let found = false;
for (let i = 0; i < zones.length; i++) {
const zone = zones[i];
if (map.forEachFeatureAtPixel(evt.pixel, function(feature) {
return feature === zone.feature;
})) {
zone.popup.setPosition(evt.coordinate);
found = true;
} else {
zone.popup.setPosition(undefined);
}
}
if (!found) {
zones.forEach(zone => zone.popup.setPosition(undefined));
}
});

// =============================
// WMSA BOUNDARY
// =============================
const wmsaCoords = [
[101.5261818612008, 3.137489173426729],
[101.5369417199503, 3.143636322688836],
[101.5554116137157, 3.114549926981039],
[101.5440129586262, 3.106801561707011],
[101.594961195717, 2.979759953663965],
[101.6583384772399, 3.017402274699589],
[101.5727587990802, 3.123805981197957],
[101.5616469816414, 3.117397632418947],
[101.5439996209306, 3.147846223647465],
[101.554999756724, 3.154278182318513],
[101.5039157532288, 3.281388971902559],
[101.440162788123, 3.24377920778443],
[101.5261818612008, 3.137489173426729]
].map(coord => ol.proj.fromLonLat(coord));

const wmsaFeature = new ol.Feature({
geometry: new ol.geom.Polygon([wmsaCoords])
});

const wmsaLayer = new ol.layer.Vector({
source: new ol.source.Vector({
features: [wmsaFeature]
}),
style: new ol.style.Style({
stroke: new ol.style.Stroke({
color: '#000',
width: 3,
lineDash: [8, 4]
}),
fill: new ol.style.Fill({
color: 'rgba(0,0,0,0)'
})
})
});

map.addLayer(wmsaLayer);

// =============================
// PANELS - INITIALLY MINIMIZED
// =============================
const rightPanel = document.getElementById('controlPanel');
const toggleRightBtn = document.getElementById('toggleRightPanelBtn');
let isRightMinimized = true;

toggleRightBtn.addEventListener('click', function() {
isRightMinimized = !isRightMinimized;
rightPanel.classList.toggle('minimized');
toggleRightBtn.textContent = isRightMinimized ? '‚ñ≤' : '‚ñº';
});

const leftPanel = document.getElementById('zoneListPanel');
const toggleLeftBtn = document.getElementById('toggleLeftPanelBtn');
let isLeftMinimized = true;

toggleLeftBtn.addEventListener('click', function() {
isLeftMinimized = !isLeftMinimized;
leftPanel.classList.toggle('minimized');
toggleLeftBtn.textContent = isLeftMinimized ? '‚ñ≤' : '‚ñº';
});

// =============================
// SEARCH FUNCTIONALITY
// =============================
const searchInput = document.getElementById('searchInput');
const zoneListContainer = document.getElementById('zoneListContainer');

searchInput.addEventListener('input', function() {
const term = this.value.toLowerCase().trim();
updateZoneList(term);

// AUTO EXPAND LEFT PANEL WHEN SEARCHING
if (term.length > 0 && isLeftMinimized) {
isLeftMinimized = false;
leftPanel.classList.remove('minimized');
toggleLeftBtn.textContent = '‚ñº';
}
});

function highlightZoneOnMap(index) {
if (index >= 0 && index < zones.length) {
const zone = zones[index];
const extent = zone.feature.getGeometry().getExtent();
map.getView().fit(extent, { padding: [50, 50, 50, 50] });
document.querySelectorAll('.zone-item').forEach(el => el.classList.remove('highlight'));
const item = document.querySelector(`.zone-item[data-index="${index}"]`);
if (item) item.classList.add('highlight');
}
}

// =============================
// COORDINATE INPUT - SINGLE INPUT
// =============================
let manualPoints = [];
const coordSection = document.getElementById('coordSection');
const pointsPreview = document.getElementById('pointsPreview');

function validateCoordinate(value, type) {
let num;
if (/[NSEW]/i.test(value)) {
num = dmsToDecimal(value.trim());
} else {
num = parseFloat(value);
}
if (isNaN(num)) {
alert(`Invalid ${type}: "${value}"`);
return null;
}
return num;
}

document.getElementById('openCoordBtn').addEventListener('click', function() {
coordSection.style.display = coordSection.style.display === 'none' ? 'block' : 'none';
});

document.getElementById('addPointBtn').addEventListener('click', function() {
const coordInput = document.getElementById('singleCoordInput');
coordInput.classList.remove('error');

const coordStr = coordInput.value.trim();
const coordsMatch = coordStr.match(/([-+]?\d+\.?\d*),\s*([-+]?\d+\.?\d*)/);

if (!coordsMatch) {
alert('Invalid coordinates format. Use: Lat, Lng (e.g., 3.137489, 101.526181)');
coordInput.classList.add('error');
return;
}

const lat = parseFloat(coordsMatch[1]);
const lng = parseFloat(coordsMatch[2]);

if (isNaN(lat) || isNaN(lng)) {
alert('Invalid coordinates. Please enter valid latitude and longitude.');
coordInput.classList.add('error');
return;
}

manualPoints.push([lng, lat]);
updatePointsPreview();
coordInput.value = '';
coordInput.focus();
});

document.getElementById('clearPointsBtn').addEventListener('click', function() {
manualPoints = [];
updatePointsPreview();
});

function updatePointsPreview() {
pointsPreview.innerHTML = '';
if (manualPoints.length === 0) {
pointsPreview.innerHTML = '<div style="color:#888; font-style:italic; font-size:11px;">No points</div>';
return;
}

manualPoints.forEach((point, index) => {
const latDMS = decimalToDMS(point[1], true);
const lngDMS = decimalToDMS(point[0], false);
const tag = document.createElement('div');
tag.className = 'point-tag';
tag.style.cssText = 'display:flex; justify-content:space-between; align-items:center; margin:1px 0;';
tag.innerHTML = `
<span style="flex:1;">${index+1}: ${latDMS}, ${lngDMS}</span>
<button type="button" onclick="removePoint(${index})" style="background:#c82333; color:white; border:none; border-radius:50%; width:16px; height:16px; font-size:10px; line-height:14px;">√ó</button>
`;
pointsPreview.appendChild(tag);
});
}

function removePoint(index) {
manualPoints.splice(index, 1);
updatePointsPreview();
}

// Create polygon from manual points
document.getElementById('createPolyBtn').addEventListener('click', function() {
if (manualPoints.length < 3) {
alert('Please add at least 3 points to create a polygon.');
return;
}

const zoneId = document.getElementById('zoneId').value.trim();
const zoneDesc = document.getElementById('zoneDesc').value.trim();
const minAlt = document.getElementById('minAlt').value ? parseInt(document.getElementById('minAlt').value) : null;
const maxAlt = document.getElementById('maxAlt').value ? parseInt(document.getElementById('maxAlt').value) : null;
const startTime = document.getElementById('startTime').value ? new Date(document.getElementById('startTime').value).toISOString() : null;
const endTime = document.getElementById('endTime').value ? new Date(document.getElementById('endTime').value).toISOString() : null;

if (!zoneId) {
alert('Please enter Zone ID.');
return;
}

// Ensure ring is closed [lon, lat]
const ringLonLat = manualPoints.slice();
const first = ringLonLat[0];
const last = ringLonLat[ringLonLat.length - 1];
if (first[0] !== last[0] || first[1] !== last[1]) {
ringLonLat.push(first);
}

// Project to map coords
const projected = ringLonLat.map(pt => ol.proj.fromLonLat(pt));

// Create feature and add as a zone
const feature = new ol.Feature({
geometry: new ol.geom.Polygon([projected])
});

const color = generateColor(zones.length);
const status = getZoneStatus(startTime, endTime);
feature.setStyle(createStyle(color, status));

createZoneFromFeature(
feature,
zoneId,
zoneDesc,
minAlt,
maxAlt,
startTime,
endTime,
color,
false,
true // mark as user-created
);

// Reset UI
manualPoints = [];
updatePointsPreview();
coordSection.style.display = 'none';
});

// =============================
// CIRCLE ZONE CREATION
// =============================
document.getElementById('createCircleBtn').addEventListener('click', function() {
const radiusNm = parseFloat(document.getElementById('circleRadiusNm').value);
const centerCoordInput = document.getElementById('circleCenterCoord');
centerCoordInput.classList.remove('error');

if (isNaN(radiusNm) || radiusNm <= 0) {
alert('Please enter a valid radius in Nautical Miles.');
return;
}

const coordStr = centerCoordInput.value.trim();
const coordsMatch = coordStr.match(/([-+]?\d+\.?\d*),\s*([-+]?\d+\.?\d*)/);

if (!coordsMatch) {
alert('Invalid coordinates format. Use: Lat, Lng (e.g., 3.137489, 101.526181)');
centerCoordInput.classList.add('error');
return;
}

const lat = parseFloat(coordsMatch[1]);
const lng = parseFloat(coordsMatch[2]);

if (isNaN(lat) || isNaN(lng)) {
alert('Invalid coordinates. Please enter valid latitude and longitude.');
centerCoordInput.classList.add('error');
return;
}

const zoneId = document.getElementById('zoneId').value.trim();
const zoneDesc = document.getElementById('zoneDesc').value.trim();
const minAlt = document.getElementById('minAlt').value ? parseInt(document.getElementById('minAlt').value) : null;
const maxAlt = document.getElementById('maxAlt').value ? parseInt(document.getElementById('maxAlt').value) : null;
const startTime = document.getElementById('startTime').value ? new Date(document.getElementById('startTime').value).toISOString() : null;
const endTime = document.getElementById('endTime').value ? new Date(document.getElementById('endTime').value).toISOString() : null;

if (!zoneId) {
alert('Please enter Zone ID.');
return;
}

// Convert Nm to meters (1 Nm = 1852 meters)
const radiusMeters = radiusNm * 1852;

// Create circle using proper trigonometric calculation
const centerCoord = ol.proj.fromLonLat([lng, lat]);
const circle = createCircleGeometry(centerCoord, radiusMeters);

const feature = new ol.Feature({
geometry: circle
});

const color = generateColor(zones.length);
const status = getZoneStatus(startTime, endTime);
feature.setStyle(createStyle(color, status));

createZoneFromFeature(
feature,
zoneId,
zoneDesc,
minAlt,
maxAlt,
startTime,
endTime,
color,
false,
true // mark as user-created
);

// Reset circle inputs
document.getElementById('circleRadiusNm').value = '';
document.getElementById('circleCenterCoord').value = '';
});

function createCircleGeometry(center, radius) {
const points = 64;
const coords = [];
const angleStep = (Math.PI * 2) / points;

for (let i = 0; i <= points; i++) {
const angle = i * angleStep;
const x = center[0] + radius * Math.cos(angle);
const y = center[1] + radius * Math.sin(angle);
coords.push([x, y]);
}

return new ol.geom.Polygon([coords]);
}

// =============================
// FILTER BUTTONS FUNCTIONALITY
// =============================
document.getElementById('showAllBtn').addEventListener('click', function() {
filterZones('all');
});

document.getElementById('showActiveBtn').addEventListener('click', function() {
filterZones('active');
});

document.getElementById('showPendingBtn').addEventListener('click', function() {
filterZones('pending');
});

document.getElementById('showExpiredBtn').addEventListener('click', function() {
filterZones('expired');
});

function filterZones(status) {
zones.forEach((zone, index) => {
const zoneStatus = getZoneStatus(zone.startTime, zone.endTime);
let visible = true;

if (status === 'active' && zoneStatus !== 'active') {
visible = false;
} else if (status === 'pending' && zoneStatus !== 'pending') {
visible = false;
} else if (status === 'expired' && zoneStatus !== 'expired') {
visible = false;
}

zone.layer.setVisible(visible);
});
}

// =============================
// DARKER COLORS FOR ATC
// =============================
const COLORS = [
'#8B0000', '#006400', '#8B8B00', '#00008B', '#8B4513',
'#4B0082', '#008B8B', '#8B008B', '#2F4F4F', '#556B2F'
];

function generateColor(index) {
return COLORS[index % COLORS.length];
}

function createStyle(color, status = 'active') {
let borderColor, borderDash;
switch(status) {
case 'active':
borderColor = '#c82333';
borderDash = [5, 5];
break;
case 'pending':
borderColor = '#0066cc';
borderDash = null;
break;
case 'expired':
borderColor = '#666666';
borderDash = null;
break;
default:
borderColor = color;
borderDash = null;
}

return new ol.style.Style({
stroke: new ol.style.Stroke({
color: borderColor,
width: 3,
lineDash: borderDash
}),
fill: new ol.style.Fill({
color: color + '66'
})
});
}

// =============================
// ZONE SYSTEM ‚Äî WITH POPUP
// =============================
function createZoneFromFeature(feature, zoneId, zoneDesc, minAlt, maxAlt, startTime, endTime, color, showLabel, isUserCreated = false) {
const source = new ol.source.Vector({ features: [feature] });
const layer = new ol.layer.Vector({ source: source });
map.addLayer(layer);

// Create popup
const popup = new ol.Overlay({
element: document.createElement('div'),
positioning: 'bottom-center',
stopEvent: false
});
map.addOverlay(popup);

const altStr = minAlt || maxAlt ? `${minAlt || 0}‚Äì${maxAlt || 'UNL'} ft` : 'No altitude';
const statusHTML = formatStatus(startTime, endTime);
const startStr = startTime ? new Date(startTime).toLocaleString('en-GB', { timeZone: 'UTC', hour12: false }) : 'N/A';
const endStr = endTime ? new Date(endTime).toLocaleString('en-GB', { timeZone: 'UTC', hour12: false }) : 'N/A';

popup.getElement().innerHTML = `
<div style="
background: #FFFFFF; color: #000000; padding: 10px 12px;
border: 2px solid #000000; border-radius: 6px;
font-family: Arial, sans-serif; font-size: 12px; font-weight: bold;
box-shadow: 0 4px 8px rgba(0,0,0,0.5); line-height: 1.4;
max-width: 220px; word-wrap: break-word;
">
<strong>${zoneId}</strong><br>
<small style="font-weight:normal;">${zoneDesc}</small><br>
<small>Alt: ${altStr}</small><br>
<small>Start: ${startStr}</small><br>
<small>End: ${endStr}</small><br>
${statusHTML}
</div>
`;

const status = getZoneStatus(startTime, endTime);

const zone = {
id: zoneId,
desc: zoneDesc,
minAlt: minAlt,
maxAlt: maxAlt,
startTime: startTime,
endTime: endTime,
layer: layer,
feature: feature,
color: color,
popup: popup,
showLabel: showLabel,
label: null,
status: status,
isUserCreated: isUserCreated // Track if user-created
};

zones.push(zone);

if (showLabel) setTimeout(() => toggleZoneLabel(zones.length - 1), 100);
updateZoneList();
saveUserZonesToStorage();

if (startTime || endTime) {
setTimeout(() => updateAllStatuses(), 1000);
}
}

// =============================
// EXPORT / IMPORT USER ZONES
// =============================
document.getElementById('exportBtn').addEventListener('click', function() {
const userZones = zones.filter(z => z.isUserCreated);
if (userZones.length === 0) {
alert("No user-created zones to export.");
return;
}

const data = userZones.map(z => {
const geom = z.feature.getGeometry();
const coords = geom.getType() === 'Polygon' ?
geom.getCoordinates()[0].map(pt => ol.proj.toLonLat(pt)) : [];
return {
id: z.id,
desc: z.desc,
minAlt: z.minAlt,
maxAlt: z.maxAlt,
startTime: z.startTime,
endTime: z.endTime,
color: z.color,
showLabel: z.showLabel,
geometry: { type: 'Polygon', coordinates: coords }
};
});

const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = `wmsa_user_zones_${new Date().toISOString().slice(0,10)}.json`;
a.click();
URL.revokeObjectURL(url);
alert(`‚úÖ Exported ${userZones.length} user zones.`);
});

document.getElementById('importBtn').addEventListener('click', function() {
document.getElementById('importFile').click();
});

document.getElementById('importFile').addEventListener('change', function(e) {
const file = e.target.files[0];
if (!file) return;

const reader = new FileReader();
reader.onload = function(ev) {
try {
const data = JSON.parse(ev.target.result);
const count = data.length;

data.forEach(item => {
if (!item.geometry?.coordinates || item.geometry.coordinates.length < 3) return;

const projectedCoords = item.geometry.coordinates.map(pt => ol.proj.fromLonLat(pt));
const feature = new ol.Feature({ geometry: new ol.geom.Polygon([projectedCoords]) });
const layer = new ol.layer.Vector({ source: new ol.source.Vector({ features: [feature] }) });

const status = getZoneStatus(item.startTime, item.endTime);
feature.setStyle(createStyle(item.color, status));
map.addLayer(layer);

// Create popup
const popup = new ol.Overlay({ element: document.createElement('div'), positioning: 'bottom-center', stopEvent: false });
map.addOverlay(popup);

const altStr = item.minAlt || item.maxAlt ? `${item.minAlt || 0}‚Äì${item.maxAlt || 'UNL'} ft` : 'No altitude';
const startStr = item.startTime ? new Date(item.startTime).toLocaleString('en-GB', { timeZone: 'UTC', hour12: false }) : 'N/A';
const endStr = item.endTime ? new Date(item.endTime).toLocaleString('en-GB', { timeZone: 'UTC', hour12: false }) : 'N/A';
const statusHTML = formatStatus(item.startTime, item.endTime);

popup.getElement().innerHTML = `
<div style="background: #FFFFFF; color: #000000; padding: 10px 12px; border: 2px solid #000000; border-radius: 6px; font-family: Arial, sans-serif; font-size: 12px; font-weight: bold; box-shadow: 0 4px 8px rgba(0,0,0,0.5); line-height: 1.4; max-width: 220px; word-wrap: break-word;">
<strong>${item.id}</strong><br>
<small style="font-weight:normal;">${item.desc}</small><br>
<small>Alt: ${altStr}</small><br>
<small>Start: ${startStr}</small><br>
<small>End: ${endStr}</small><br>
${statusHTML}
</div>
`;

const zoneStatus = getZoneStatus(item.startTime, item.endTime);
const zone = {
id: item.id, desc: item.desc, minAlt: item.minAlt, maxAlt: item.maxAlt,
startTime: item.startTime, endTime: item.endTime, layer: layer, feature: feature,
color: item.color, popup: popup, showLabel: item.showLabel, label: null,
status: zoneStatus, isUserCreated: true
};

zones.push(zone);
});

setTimeout(() => {
zones.slice(-count).forEach((zone, idx) => {
if (zone.showLabel) toggleZoneLabel(zones.length - count + idx);
});
}, 500);

updateZoneList();
saveUserZonesToStorage();
alert(`‚úÖ Imported ${count} user zones.`);
} catch (error) {
console.error("Import failed:", error);
alert("‚ùå Failed to import zones: " + error.message);
}
};
reader.readAsText(file);
this.value = '';
});

// =============================
// EDIT/DELETE ZONE
// =============================
let currentEditIndex = -1;

function editZone(index) {
if (index < 0 || index >= zones.length) return;
const zone = zones[index];
currentEditIndex = index;
document.getElementById('editId').value = zone.id;
document.getElementById('editDesc').value = zone.desc;
document.getElementById('editMinAlt').value = zone.minAlt || '';
document.getElementById('editMaxAlt').value = zone.maxAlt || '';
document.getElementById('editStartTime').value = zone.startTime ? new Date(zone.startTime).toISOString().slice(0,16) : '';
document.getElementById('editEndTime').value = zone.endTime ? new Date(zone.endTime).toISOString().slice(0,16) : '';
document.getElementById('editModal').style.display = 'block';
}

document.getElementById('saveEditBtn').addEventListener('click', function() {
if (currentEditIndex < 0) return;
const zone = zones[currentEditIndex];
zone.id = document.getElementById('editId').value.trim() || zone.id;
zone.desc = document.getElementById('editDesc').value.trim() || zone.desc;
zone.minAlt = document.getElementById('editMinAlt').value ? parseInt(document.getElementById('editMinAlt').value) : null;
zone.maxAlt = document.getElementById('editMaxAlt').value ? parseInt(document.getElementById('editMaxAlt').value) : null;
zone.startTime = document.getElementById('editStartTime').value ? new Date(document.getElementById('editStartTime').value).toISOString() : null;
zone.endTime = document.getElementById('editEndTime').value ? new Date(document.getElementById('editEndTime').value).toISOString() : null;
zone.status = getZoneStatus(zone.startTime, zone.endTime);
zone.feature.setStyle(createStyle(zone.color, zone.status));
zone.isUserCreated = true; // Mark as user-modified

const altStr = zone.minAlt || zone.maxAlt ? `${zone.minAlt || 0}‚Äì${zone.maxAlt || 'UNL'} ft` : 'No altitude';
const startStr = zone.startTime ? new Date(zone.startTime).toLocaleString('en-GB', { timeZone: 'UTC', hour12: false }) : 'N/A';
const endStr = zone.endTime ? new Date(zone.endTime).toLocaleString('en-GB', { timeZone: 'UTC', hour12: false }) : 'N/A';
const statusHTML = formatStatus(zone.startTime, zone.endTime);

zone.popup.getElement().innerHTML = `
<div style="background: #FFFFFF; color: #000000; padding: 10px 12px; border: 2px solid #000000; border-radius: 6px; font-family: Arial, sans-serif; font-size: 12px; font-weight: bold; box-shadow: 0 4px 8px rgba(0,0,0,0.5); line-height: 1.4; max-width: 220px; word-wrap: break-word;">
<strong>${zone.id}</strong><br>
<small style="font-weight:normal;">${zone.desc}</small><br>
<small>Alt: ${altStr}</small><br>
<small>Start: ${startStr}</small><br>
<small>End: ${endStr}</small><br>
${statusHTML}
</div>
`;

if (zone.showLabel) toggleZoneLabel(currentEditIndex);
updateZoneList();
saveUserZonesToStorage();
document.getElementById('editModal').style.display = 'none';
});

document.getElementById('cancelEditBtn').addEventListener('click', function() {
document.getElementById('editModal').style.display = 'none';
});

function confirmDeleteZone(index) {
if (index >= 0 && index < zones.length) {
const zoneId = zones[index].id;
if (confirm(`Delete zone "${zoneId}"?`)) deleteZone(index);
}
}

function deleteZone(index) {
if (index >= 0 && index < zones.length) {
const zone = zones[index];
map.removeLayer(zone.layer);
if (zone.popup) map.removeOverlay(zone.popup);
if (zone.label) map.removeOverlay(zone.label);
zones.splice(index, 1);
updateZoneList();
saveUserZonesToStorage();
}
}

// =============================
// TOGGLE LABEL
// =============================
function toggleZoneLabel(index) {
if (index >= 0 && index < zones.length) {
const zone = zones[index];
if (zone.showLabel) {
if (zone.label) map.removeOverlay(zone.label);
zone.label = null;
} else {
const geom = zone.feature.getGeometry();
const center = geom.getType() === 'Polygon' ?
geom.getInteriorPoint().getCoordinates() : geom.getExtent();
if (!Array.isArray(center)) {
center = [(geom[0] + geom[2])/2, (geom[1] + geom[3])/2];
}
const status = getZoneStatus(zone.startTime, zone.endTime);
const statusPrefix = status === 'pending' ? '[PENDING] ' : status === 'expired' ? '[EXPIRED] ' : '[ACTIVE] ';
const altStr = zone.minAlt || zone.maxAlt ? `(${zone.minAlt || 0}‚Äì${zone.maxAlt || 'UNL'} ft)` : '';
const labelStr = `${statusPrefix}${zone.id} ${zone.desc} ${altStr}`;
const labelElement = document.createElement('div');
labelElement.innerHTML = `<div style="background: #FFFFFF; color: #000000; padding: 4px 6px; border: 2px solid #000000; border-radius: 4px; font-size: 10px; font-weight: bold; text-align: center; word-wrap: break-word; max-width: 200px; line-height: 1.3; box-shadow: 0 2px 4px rgba(0,0,0,0.5);">${labelStr}</div>`;
const label = new ol.Overlay({ position: center, positioning: 'center-center', element: labelElement, stopEvent: false });
map.addOverlay(label);
zone.label = label;
}
zone.showLabel = !zone.showLabel;
saveUserZonesToStorage();
}
}

// =============================
// ZONE LIST
// =============================
function updateZoneList(filterTerm = '') {
const container = document.getElementById('zoneListContainer');
const header = leftPanel.querySelector('h3');
header.textContent = `üìã Zones (${zones.length})`;
container.innerHTML = '';
if (zones.length === 0) {
container.innerHTML = '<div style="padding:10px; color:#888; font-size:12px;">No active zones</div>';
return;
}
const filteredZones = filterTerm ? zones.filter(z => z.id.toLowerCase().includes(filterTerm) || z.desc.toLowerCase().includes(filterTerm)) : zones;
if (filteredZones.length === 0 && filterTerm) {
container.innerHTML = '<div style="padding:10px; color:#888; font-size:12px;">No matching zones</div>';
return;
}
filteredZones.forEach((zone, index) => {
const originalIndex = zones.indexOf(zone);
const altStr = zone.minAlt || zone.maxAlt ? `(${zone.minAlt || 0}‚Äì${zone.maxAlt || 'UNL'} ft)` : '';
const statusHTML = formatStatus(zone.startTime, zone.endTime);
const item = document.createElement('div');
item.className = 'zone-item';
item.setAttribute('data-index', originalIndex);
item.innerHTML = `
<div class="zone-header">
<div style="display:flex; align-items:center;">
<div class="color-box" style="background:${zone.color};"></div>
<strong>${zone.id}</strong>
${zone.isUserCreated ? '<span style="margin-left:6px; color:#28a745; font-size:10px; font-weight:normal;">(USER)</span>' : ''}
</div>
<div class="zone-actions">
<button class="edit-icon" onclick="editZone(${originalIndex})">‚úé</button>
<button class="delete-icon" onclick="confirmDeleteZone(${originalIndex})">√ó</button>
</div>
</div>
<div class="zone-main" style="align-items: flex-start;">
<div class="zone-desc" style="flex:1; word-wrap: break-word;">${zone.desc} ${altStr}</div>
<div class="toggle-label-icon" onclick="toggleZoneLabel(${originalIndex})" title="Toggle label">
<span style="display: inline-block; background: white; color: black; border: 2px solid black; border-radius: 4px; padding: 2px 6px; font-size: 16px; font-weight: bold; line-height: 1; text-align: center;">${zone.showLabel ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è'}</span>
</div>
</div>
<div><small class="zone-status">${statusHTML}</small></div>
`;
item.addEventListener('click', function(e) {
if (!e.target.closest('.edit-icon') && !e.target.closest('.delete-icon') && !e.target.closest('.toggle-label-icon')) {
highlightZoneOnMap(originalIndex);
}
});
container.appendChild(item);
});
}

// =============================
// TIME & STATUS
// =============================
function formatDuration(ms) {
if (ms < 0) ms = -ms;
const d = Math.floor(ms / 86400000);
const h = Math.floor((ms % 86400000) / 3600000);
const m = Math.floor((ms % 3600000) / 60000);
return `${d}d ${h}h ${m}m`;
}

function getZoneStatus(start, end) {
const now = new Date();
if (start && now < new Date(start)) return 'pending';
if (end && now > new Date(end)) return 'expired';
return 'active';
}

function formatStatus(start, end) {
const now = new Date();
const s = getZoneStatus(start, end);
function formatTime(date) {
const d = String(date.getDate()).padStart(2, '0');
const m = String(date.getMonth() + 1).padStart(2, '0');
const h = String(date.getHours()).padStart(2, '0');
const min = String(date.getMinutes()).padStart(2, '0');
return `${h}:${min} ${d}/${m}`;
}
if (s === 'pending' && start) {
const startDate = new Date(start);
return `<span class="status-pending">üü¶ PENDING from ${formatTime(startDate)} (+${formatDuration(startDate - now)})</span>`;
}
if (s === 'active' && end) {
const endDate = new Date(end);
return `<span class="status-active">üü• ACTIVE until ${formatTime(endDate)} (${formatDuration(endDate - now)})</span>`;
}
if (s === 'expired' && end) {
const endDate = new Date(end);
return `<span class="status-expired">‚¨ú EXPIRED at ${formatTime(endDate)} (${formatDuration(now - endDate)} ago)</span>`;
}
return "<span style='color:#888; font-size:11px;'>üïí No time</span>";
}

function updateAllStatuses() {
zones.forEach((zone, index) => {
const newStatus = getZoneStatus(zone.startTime, zone.endTime);
if (zone.status !== newStatus) {
zone.status = newStatus;
zone.feature.setStyle(createStyle(zone.color, newStatus));
}
if (zone.label && zone.showLabel) toggleZoneLabel(index);
});
setTimeout(updateAllStatuses, 60000);
}

// =============================
// USER ZONES PERSISTENCE
// =============================
function saveUserZonesToStorage() {
const userZones = zones.filter(z => z.isUserCreated).map(z => {
const geom = z.feature.getGeometry();
const coords = geom.getType() === 'Polygon' ? geom.getCoordinates()[0].map(pt => ol.proj.toLonLat(pt)) : [];
return {
id: z.id, desc: z.desc, minAlt: z.minAlt, maxAlt: z.maxAlt,
startTime: z.startTime, endTime: z.endTime, color: z.color,
showLabel: z.showLabel, geometry: { type: 'Polygon', coordinates: coords }
};
});
localStorage.setItem(USER_DATA_KEY, JSON.stringify(userZones));
}

function loadUserZonesFromStorage() {
const saved = localStorage.getItem(USER_DATA_KEY);
if (!saved) return;
try {
const data = JSON.parse(saved);
data.forEach(item => {
if (!item.geometry?.coordinates || item.geometry.coordinates.length < 3) return;
const projectedCoords = item.geometry.coordinates.map(pt => ol.proj.fromLonLat(pt));
const feature = new ol.Feature({ geometry: new ol.geom.Polygon([projectedCoords]) });
const layer = new ol.layer.Vector({ source: new ol.source.Vector({ features: [feature] }) });
const status = getZoneStatus(item.startTime, item.endTime);
feature.setStyle(createStyle(item.color, status));
map.addLayer(layer);
const popup = new ol.Overlay({ element: document.createElement('div'), positioning: 'bottom-center', stopEvent: false });
map.addOverlay(popup);
const altStr = item.minAlt || item.maxAlt ? `${item.minAlt || 0}‚Äì${item.maxAlt || 'UNL'} ft` : 'No altitude';
const startStr = item.startTime ? new Date(item.startTime).toLocaleString('en-GB', { timeZone: 'UTC', hour12: false }) : 'N/A';
const endStr = item.endTime ? new Date(item.endTime).toLocaleString('en-GB', { timeZone: 'UTC', hour12: false }) : 'N/A';
const statusHTML = formatStatus(item.startTime, item.endTime);
popup.getElement().innerHTML = `
<div style="background: #FFFFFF; color: #000000; padding: 10px 12px; border: 2px solid #000000; border-radius: 6px; font-family: Arial, sans-serif; font-size: 12px; font-weight: bold; box-shadow: 0 4px 8px rgba(0,0,0,0.5); line-height: 1.4; max-width: 220px; word-wrap: break-word;">
<strong>${item.id}</strong><br>
<small style="font-weight:normal;">${item.desc}</small><br>
<small>Alt: ${altStr}</small><br>
<small>Start: ${startStr}</small><br>
<small>End: ${endStr}</small><br>
${statusHTML}
</div>
`;
const zoneStatus = getZoneStatus(item.startTime, item.endTime);
const zone = {
id: item.id, desc: item.desc, minAlt: item.minAlt, maxAlt: item.maxAlt,
startTime: item.startTime, endTime: item.endTime, layer: layer, feature: feature,
color: item.color, popup: popup, showLabel: item.showLabel, label: null,
status: zoneStatus, isUserCreated: true
};
zones.push(zone);
});
setTimeout(() => {
const userCount = data.length;
zones.slice(-userCount).forEach((zone, idx) => {
if (zone.showLabel) toggleZoneLabel(zones.length - userCount + idx);
});
updateZoneList();
}, 500);
} catch(e) { console.error("Failed to load user zones:", e); }
}

// =============================
// LOAD DATA FROM notams.json
// =============================
async function loadNotamsData() {
try {
const response = await fetch(DATA_FILE);
if (!response.ok) {
throw new Error(`Failed to load ${DATA_FILE}: ${response.status} ${response.statusText}`);
}
const data = await response.json();
document.getElementById('lastUpdated').textContent = new Date().toLocaleString('en-GB', { timeZone: 'UTC', hour12: false });

data.forEach(item => {
if (!item.geometry?.coordinates || item.geometry.coordinates.length < 3) return;
const projectedCoords = item.geometry.coordinates.map(pt => ol.proj.fromLonLat(pt));
const feature = new ol.Feature({ geometry: new ol.geom.Polygon([projectedCoords]) });
const layer = new ol.layer.Vector({ source: new ol.source.Vector({ features: [feature] }) });
const status = getZoneStatus(item.startTime, item.endTime);
feature.setStyle(createStyle(item.color, status));
map.addLayer(layer);
const popup = new ol.Overlay({ element: document.createElement('div'), positioning: 'bottom-center', stopEvent: false });
map.addOverlay(popup);
const altStr = item.minAlt || item.maxAlt ? `${item.minAlt || 0}‚Äì${item.maxAlt || 'UNL'} ft` : 'No altitude';
const startStr = item.startTime ? new Date(item.startTime).toLocaleString('en-GB', { timeZone: 'UTC', hour12: false }) : 'N/A';
const endStr = item.endTime ? new Date(item.endTime).toLocaleString('en-GB', { timeZone: 'UTC', hour12: false }) : 'N/A';
const statusHTML = formatStatus(item.startTime, item.endTime);
popup.getElement().innerHTML = `
<div style="background: #FFFFFF; color: #000000; padding: 10px 12px; border: 2px solid #000000; border-radius: 6px; font-family: Arial, sans-serif; font-size: 12px; font-weight: bold; box-shadow: 0 4px 8px rgba(0,0,0,0.5); line-height: 1.4; max-width: 220px; word-wrap: break-word;">
<strong>${item.id}</strong><br>
<small style="font-weight:normal;">${item.desc}</small><br>
<small>Alt: ${altStr}</small><br>
<small>Start: ${startStr}</small><br>
<small>End: ${endStr}</small><br>
${statusHTML}
</div>
`;
const zoneStatus = getZoneStatus(item.startTime, item.endTime);
const zone = {
id: item.id, desc: item.desc, minAlt: item.minAlt, maxAlt: item.maxAlt,
startTime: item.startTime, endTime: item.endTime, layer: layer, feature: feature,
color: item.color, popup: popup, showLabel: item.showLabel, label: null,
status: zoneStatus, isUserCreated: false
};
zones.push(zone);
});

setTimeout(() => {
zones.forEach((zone, index) => {
if (zone.showLabel) toggleZoneLabel(index);
});
updateZoneList();
hideLoading();
if (zones.some(z => z.startTime || z.endTime)) setTimeout(updateAllStatuses, 1000);
}, 500);

} catch (error) {
console.error("Error loading NOTAM data:", error);
showError(`‚ùå ${error.message}. Please ensure notams.json exists.`);
hideLoading();
}
}

// INIT - LOAD DATA
loadNotamsData();
loadUserZonesFromStorage();
</script>
</body>
</html>
